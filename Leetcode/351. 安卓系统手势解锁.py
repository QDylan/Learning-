# -*- coding: utf-8 -*-
"""
 @Time    : 2020/7/27 15:53
 @Author  : QDY
 @FileName: 351. 安卓系统手势解锁.py
 @Software: PyCharm
"""
"""
我们都知道安卓有个手势解锁的界面，是一个 3 x 3 的点所绘制出来的网格。
给你两个整数，分别为 ​​m 和 n，其中 1 ≤ m ≤ n ≤ 9，那么请你统计一下有多少种解锁手势，是至少需要经过 m 个点，但是最多经过不超过 n 个点的。

 
先来了解下什么是一个有效的安卓解锁手势:
每一个解锁手势必须至少经过 m 个点、最多经过 n 个点。
解锁手势里不能设置经过重复的点。
假如手势中有两个点是顺序经过的，那么这两个点的手势轨迹之间是绝对不能跨过任何未被经过的点。
经过点的顺序不同则表示为不同的解锁手势。
 

解释:

| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |
无效手势：4 - 1 - 3 - 6
连接点 1 和点 3 时经过了未被连接过的 2 号点。

无效手势：4 - 1 - 9 - 2
连接点 1 和点 9 时经过了未被连接过的 5 号点。

有效手势：2 - 4 - 1 - 3 - 6
连接点 1 和点 3 是有效的，因为虽然它经过了点 2 ，但是点 2 在该手势中之前已经被连过了。

有效手势：6 - 5 - 4 - 1 - 9 - 2
连接点 1 和点 9 是有效的，因为虽然它经过了按键 5 ，但是点 5 在该手势中之前已经被连过了。

示例:
输入: m = 1，n = 1
输出: 9

"""


class Solution:
    def numberOfPatterns(self, m: int, n: int) -> int:
        unable = {(1, 3): 2, (1, 7): 4, (3, 9): 6, (7, 9): 8, (3, 7): 5, (1, 9): 5, (2, 8): 5, (4, 6): 5, (3, 1): 2,
                  (7, 1): 4, (9, 3): 6, (9, 7): 8, (7, 3): 5, (9, 1): 5, (8, 2): 5, (6, 4): 5}

        self.res = 0
        nums = [i for i in range(1, 10)]

        def dfs(rest, prev, cnt):
            if cnt == n:
                self.res += 1
                return
            if cnt >= m:
                self.res += 1
            for i in range(len(rest)):
                if (prev, rest[i]) in unable and unable[(prev, rest[i])] in rest:
                    continue
                else:
                    dfs(rest[:i] + rest[i + 1:], rest[i], cnt + 1)

        dfs(nums, 0, 0)
        return self.res